# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

#1.Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.

Если я правильно понял интерпритацию, единственный вызов`    `chdir("/tmp")

#2.Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
#vagrant@netology1:~$ file /dev/tty
    dev/tty: character special (5/0)
#vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
#vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
#Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

    Опираясь на man file и вывод strace:
    openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
    openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

#3.Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

    Зная PID процесса, помеченного (deleted), использовал: > /proc/<PID>/fd/<Дескриптор этого процесса>

#4.Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

    Зомби процессы продолжают висеть в памяти, пока не будет завершён их родительский процесс.

#5.В iovisor BCC есть утилита opensnoop:
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin
    /opensnoop/usr/sbin/opensnoop-bpfcc
#На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.

    sudo /usr/sbin/opensnoop-bpfcc

    PID    COMM               FD ERR PATH
    736    irqbalance          7   0 /proc/interrupts
    736    irqbalance          7   0 /proc/stat
    736    irqbalance          7   0 /proc/irq/54/smp_affinity
    736    irqbalance          7   0 /proc/irq/59/smp_affinity
    736    irqbalance          7   0 /proc/irq/59/smp_affinity
    736    irqbalance          7   0 /proc/irq/61/smp_affinity
    736    irqbalance          7   0 /proc/irq/43/smp_affinity
    736    irqbalance          7   0 /proc/irq/44/smp_affinity
    736    irqbalance          7   0 /proc/irq/2/smp_affinity
    736    irqbalance          7   0 /proc/irq/4/smp_affinity
    736    irqbalance          7   0 /proc/irq/41/smp_affinity
    736    irqbalance          7   0 /proc/irq/42/smp_affinity

#6.Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
    
    uname, судя по всему, и есть системный вызов

    Из MAN: Part of the utsname information is also accessible  via  /proc/sys/ker‐
       nel/{ostype, hostname, osrelease, version, domainname}.

    
#7.Чем отличается последовательность команд через ; и через && в bash? Например:

    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#

`    `в случае применения ; команды будут выполняться последовательно внезависимости от результата исполнения первой команды, когда как при && выполнится вторая команда, если результат первой будет без ошибки.

#Есть ли смысл использовать в bash &&, если применить set -e?

`    `Опытным путем выяснил set -e завершит консоль при возникновении ошибки, при этом если использовать &&, (например set -e | lsd && ls), то консоль продолжит работу.

#8.Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

    e - немедленно завершает терминал, если результата команды ненулевой.
    u - оболочка проверяет инициализацию переменных в скрипте. Если переменной не будет, скрипт немедленно завершиться.
    x - bash печатает в стандартный вывод все команды перед их исполнением.
    o pipefail -  если нужно убедиться, что все команды в конвеере завершились успешно.

    Таким образом set -euxo pipefail используется для безопасного вылова ошибок при отладке и аварийного завершения скрипта.

#9.Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

    S - неактивен менее 20 секунд.
    I - неактивен более 20 секунд